{
  "version": 3,
  "sources": ["../../src/AuthContext.ts", "../../src/AuthProvider.tsx", "../../src/AuthState.ts", "../../src/reducer.ts", "../../src/utils.ts", "../../src/useAuth.ts", "../../src/withAuth.tsx", "../../src/withAuthenticationRequired.tsx"],
  "sourcesContent": ["import React from \"react\";\r\nimport type {\r\n    UserManagerSettings, UserManagerEvents, User, SessionStatus,\r\n    SigninPopupArgs, SigninSilentArgs, SigninRedirectArgs,\r\n    SignoutRedirectArgs, SignoutPopupArgs, QuerySessionStatusArgs,\r\n    RevokeTokensTypes, SignoutSilentArgs, SigninResourceOwnerCredentialsArgs,\r\n} from \"oidc-client-ts\";\r\n\r\nimport type { AuthState } from \"./AuthState\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface AuthContextProps extends AuthState {\r\n    /**\r\n     * UserManager functions. See [UserManager](https://github.com/authts/oidc-client-ts) for more details.\r\n     */\r\n    readonly settings: UserManagerSettings;\r\n    readonly events: UserManagerEvents;\r\n    clearStaleState(): Promise<void>;\r\n    removeUser(): Promise<void>;\r\n    signinPopup(args?: SigninPopupArgs): Promise<User>;\r\n    signinSilent(args?: SigninSilentArgs): Promise<User | null>;\r\n    signinRedirect(args?: SigninRedirectArgs): Promise<void>;\r\n    signinResourceOwnerCredentials(args: SigninResourceOwnerCredentialsArgs): Promise<User>;\r\n    signoutRedirect(args?: SignoutRedirectArgs): Promise<void>;\r\n    signoutPopup(args?: SignoutPopupArgs): Promise<void>;\r\n    signoutSilent(args?: SignoutSilentArgs): Promise<void>;\r\n    querySessionStatus(args?: QuerySessionStatusArgs): Promise<SessionStatus | null>;\r\n    revokeTokens(types?: RevokeTokensTypes): Promise<void>;\r\n    startSilentRenew(): void;\r\n    stopSilentRenew(): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const AuthContext = React.createContext<AuthContextProps | undefined>(undefined);\r\nAuthContext.displayName = \"AuthContext\";\r\n", "import React from \"react\";\r\nimport { UserManager, type UserManagerSettings, User } from \"oidc-client-ts\";\r\nimport type {\r\n    ProcessResourceOwnerPasswordCredentialsArgs,\r\n    SignoutResponse,\r\n} from \"oidc-client-ts\";\r\n\r\nimport { AuthContext } from \"./AuthContext\";\r\nimport { initialAuthState } from \"./AuthState\";\r\nimport { reducer } from \"./reducer\";\r\nimport { hasAuthParams, signinError, signoutError } from \"./utils\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface AuthProviderBaseProps {\r\n    /**\r\n     * The child nodes your Provider has wrapped\r\n     */\r\n    children?: React.ReactNode;\r\n\r\n    /**\r\n     * On sign in callback hook. Can be a async function.\r\n     * Here you can remove the code and state parameters from the url when you are redirected from the authorize page.\r\n     *\r\n     * ```jsx\r\n     * const onSigninCallback = (_user: User | undefined): void => {\r\n     *     window.history.replaceState(\r\n     *         {},\r\n     *         document.title,\r\n     *         window.location.pathname\r\n     *     )\r\n     * }\r\n     * ```\r\n     */\r\n    onSigninCallback?: (user: User | undefined) => Promise<void> | void;\r\n\r\n    /**\r\n     * By default, if the page url has code/state params, this provider will call automatically the `userManager.signinCallback`.\r\n     * In some cases the code might be for something else (another OAuth SDK perhaps). In these\r\n     * instances you can instruct the client to ignore them.\r\n     *\r\n     * ```jsx\r\n     * <AuthProvider\r\n     *   skipSigninCallback={window.location.pathname === \"/stripe-oauth-callback\"}\r\n     * >\r\n     * ```\r\n     */\r\n    skipSigninCallback?: boolean;\r\n\r\n    /**\r\n      * Match the redirect uri used for logout (e.g. `post_logout_redirect_uri`)\r\n      * This provider will then call automatically the `userManager.signoutCallback`.\r\n      *\r\n      * HINT:\r\n      * Do not call `userManager.signoutRedirect()` within a `React.useEffect`, otherwise the\r\n      * logout might be unsuccessful.\r\n      *\r\n      * ```jsx\r\n      * <AuthProvider\r\n      *   matchSignoutCallback={(args) => {\r\n      *     window &&\r\n      *     (window.location.href === args.post_logout_redirect_uri);\r\n      *   }}\r\n      * ```\r\n      */\r\n    matchSignoutCallback?: (args: UserManagerSettings) => boolean;\r\n\r\n    /**\r\n     * On sign out callback hook. Can be a async function.\r\n     * Here you can change the url after the user is signed out.\r\n     * When using this, specifying `matchSignoutCallback` is required.\r\n     *\r\n     * ```jsx\r\n     * const onSignoutCallback = (resp: SignoutResponse | undefined): void => {\r\n     *     // go to home after logout\r\n     *     window.location.pathname = \"\"\r\n     * }\r\n     * ```\r\n     */\r\n    onSignoutCallback?: (resp: SignoutResponse | undefined) => Promise<void> | void;\r\n\r\n    /**\r\n     * On remove user hook. Can be a async function.\r\n     * Here you can change the url after the user is removed.\r\n     *\r\n     * ```jsx\r\n     * const onRemoveUser = (): void => {\r\n     *     // go to home after logout\r\n     *     window.location.pathname = \"\"\r\n     * }\r\n     * ```\r\n     */\r\n    onRemoveUser?: () => Promise<void> | void;\r\n}\r\n\r\n/**\r\n * This interface (default) is used to pass `UserManagerSettings` together with `AuthProvider` properties to the provider.\r\n *\r\n * @public\r\n */\r\nexport interface AuthProviderNoUserManagerProps extends AuthProviderBaseProps, UserManagerSettings {\r\n    /**\r\n     * Prevent this property.\r\n     */\r\n    userManager?: never;\r\n}\r\n\r\n/**\r\n * This interface is used to pass directly a `UserManager` instance together with `AuthProvider` properties to the provider.\r\n *\r\n * @public\r\n */\r\nexport interface AuthProviderUserManagerProps extends AuthProviderBaseProps {\r\n    /**\r\n     * Allow passing a custom UserManager instance.\r\n     */\r\n    userManager?: UserManager;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport type AuthProviderProps = AuthProviderNoUserManagerProps | AuthProviderUserManagerProps;\r\n\r\nconst userManagerContextKeys = [\r\n    \"clearStaleState\",\r\n    \"querySessionStatus\",\r\n    \"revokeTokens\",\r\n    \"startSilentRenew\",\r\n    \"stopSilentRenew\",\r\n] as const;\r\nconst navigatorKeys = [\r\n    \"signinPopup\",\r\n    \"signinSilent\",\r\n    \"signinRedirect\",\r\n    \"signinResourceOwnerCredentials\",\r\n    \"signoutPopup\",\r\n    \"signoutRedirect\",\r\n    \"signoutSilent\",\r\n] as const;\r\nconst unsupportedEnvironment = (fnName: string) => () => {\r\n    throw new Error(\r\n        `UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`,\r\n    );\r\n};\r\nconst UserManagerImpl =\r\n    typeof window === \"undefined\" ? null : UserManager;\r\n\r\n/**\r\n * Provides the AuthContext to its child components.\r\n *\r\n * @public\r\n */\r\nexport const AuthProvider = (props: AuthProviderProps): React.JSX.Element => {\r\n    const {\r\n        children,\r\n\r\n        onSigninCallback,\r\n        skipSigninCallback,\r\n\r\n        matchSignoutCallback,\r\n        onSignoutCallback,\r\n\r\n        onRemoveUser,\r\n\r\n        userManager: userManagerProp = null,\r\n        ...userManagerSettings\r\n    } = props;\r\n\r\n    const [userManager] = React.useState(() => {\r\n        return userManagerProp ??\r\n            (UserManagerImpl\r\n                ? new UserManagerImpl(userManagerSettings as UserManagerSettings)\r\n                : ({ settings: userManagerSettings } as UserManager));\r\n    });\r\n\r\n    const [state, dispatch] = React.useReducer(reducer, initialAuthState);\r\n    const userManagerContext = React.useMemo(\r\n        () =>\r\n            Object.assign(\r\n                {\r\n                    settings: userManager.settings,\r\n                    events: userManager.events,\r\n                },\r\n                Object.fromEntries(\r\n                    userManagerContextKeys.map((key) => [\r\n                        key,\r\n                        userManager[key]?.bind(userManager) ??\r\n                            unsupportedEnvironment(key),\r\n                    ]),\r\n                ) as Pick<UserManager, typeof userManagerContextKeys[number]>,\r\n                Object.fromEntries(\r\n                    navigatorKeys.map((key) => [\r\n                        key,\r\n                        userManager[key]\r\n                            ? async (args: ProcessResourceOwnerPasswordCredentialsArgs & never[]) => {\r\n                                dispatch({\r\n                                    type: \"NAVIGATOR_INIT\",\r\n                                    method: key,\r\n                                });\r\n                                try {\r\n                                    return await userManager[key](args);\r\n                                } catch (error) {\r\n                                    dispatch({ type: \"ERROR\", error: error as Error });\r\n                                    return null;\r\n                                } finally {\r\n                                    dispatch({ type: \"NAVIGATOR_CLOSE\" });\r\n                                }\r\n                            }\r\n                            : unsupportedEnvironment(key),\r\n                    ]),\r\n                ) as Pick<UserManager, typeof navigatorKeys[number]>,\r\n            ),\r\n        [userManager],\r\n    );\r\n    const didInitialize = React.useRef(false);\r\n\r\n    React.useEffect(() => {\r\n        if (!userManager || didInitialize.current) {\r\n            return;\r\n        }\r\n        didInitialize.current = true;\r\n\r\n        void (async (): Promise<void> => {\r\n            // sign-in\r\n            try {\r\n                let user: User | undefined | null = null;\r\n\r\n                // check if returning back from authority server\r\n                if (hasAuthParams() && !skipSigninCallback) {\r\n                    user = await userManager.signinCallback();\r\n                    if (onSigninCallback) await onSigninCallback(user);\r\n                }\r\n                user = !user ? await userManager.getUser() : user;\r\n                dispatch({ type: \"INITIALISED\", user });\r\n            } catch (error) {\r\n                dispatch({ type: \"ERROR\", error: signinError(error) });\r\n            }\r\n\r\n            // sign-out\r\n            try {\r\n                if (matchSignoutCallback && matchSignoutCallback(userManager.settings)) {\r\n                    const resp = await userManager.signoutCallback();\r\n                    if (onSignoutCallback) await onSignoutCallback(resp);\r\n                }\r\n            } catch (error) {\r\n                dispatch({ type: \"ERROR\", error: signoutError(error) });\r\n            }\r\n        })();\r\n    }, [userManager, skipSigninCallback, onSigninCallback, onSignoutCallback, matchSignoutCallback]);\r\n\r\n    // register to userManager events\r\n    React.useEffect(() => {\r\n        if (!userManager) return undefined;\r\n        // event UserLoaded (e.g. initial load, silent renew success)\r\n        const handleUserLoaded = (user: User) => {\r\n            dispatch({ type: \"USER_LOADED\", user });\r\n        };\r\n        userManager.events.addUserLoaded(handleUserLoaded);\r\n\r\n        // event UserUnloaded (e.g. userManager.removeUser)\r\n        const handleUserUnloaded = () => {\r\n            dispatch({ type: \"USER_UNLOADED\" });\r\n        };\r\n        userManager.events.addUserUnloaded(handleUserUnloaded);\r\n\r\n        // event UserSignedOut (e.g. user was signed out in background (checkSessionIFrame option))\r\n        const handleUserSignedOut = () => {\r\n            dispatch({ type: \"USER_SIGNED_OUT\" });\r\n        };\r\n        userManager.events.addUserSignedOut(handleUserSignedOut);\r\n\r\n        // event SilentRenewError (silent renew error)\r\n        const handleSilentRenewError = (error: Error) => {\r\n            dispatch({ type: \"ERROR\", error });\r\n        };\r\n        userManager.events.addSilentRenewError(handleSilentRenewError);\r\n\r\n        return () => {\r\n            userManager.events.removeUserLoaded(handleUserLoaded);\r\n            userManager.events.removeUserUnloaded(handleUserUnloaded);\r\n            userManager.events.removeUserSignedOut(handleUserSignedOut);\r\n            userManager.events.removeSilentRenewError(handleSilentRenewError);\r\n        };\r\n    }, [userManager]);\r\n\r\n    const removeUser = React.useCallback(async () => {\r\n        if (!userManager) unsupportedEnvironment(\"removeUser\");\r\n        await userManager.removeUser();\r\n        if (onRemoveUser) await onRemoveUser();\r\n    }, [userManager, onRemoveUser]);\r\n\r\n    const contextValue = React.useMemo(() => {\r\n        return {\r\n            ...state,\r\n            ...userManagerContext,\r\n            removeUser,\r\n        };\r\n    }, [state, userManagerContext, removeUser]);\r\n\r\n    return (\r\n        <AuthContext.Provider value={contextValue}>\r\n            {children}\r\n        </AuthContext.Provider>\r\n    );\r\n};\r\n", "import type { User } from \"oidc-client-ts\";\r\n\r\n/**\r\n * The auth state which, when combined with the auth methods, make up the return object of the `useAuth` hook.\r\n *\r\n * @public\r\n */\r\nexport interface AuthState {\r\n    /**\r\n     * See [User](https://authts.github.io/oidc-client-ts/classes/User.html) for more details.\r\n     */\r\n    user?: User | null;\r\n\r\n    /**\r\n     * True when the library has been initialized and no navigator request is in progress.\r\n     */\r\n    isLoading: boolean;\r\n\r\n    /**\r\n     * True while the user has a valid access token.\r\n     */\r\n    isAuthenticated: boolean;\r\n\r\n    /**\r\n     * Tracks the status of most recent signin/signout request method.\r\n     */\r\n    activeNavigator?: \"signinRedirect\" | \"signinResourceOwnerCredentials\" | \"signinPopup\" | \"signinSilent\" | \"signoutRedirect\" | \"signoutPopup\" | \"signoutSilent\";\r\n\r\n    /**\r\n     * Was there a signin or silent renew error?\r\n     */\r\n    error?: Error;\r\n}\r\n\r\n/**\r\n * The initial auth state.\r\n */\r\nexport const initialAuthState: AuthState = {\r\n    isLoading: true,\r\n    isAuthenticated: false,\r\n};\r\n", "import type { User } from \"oidc-client-ts\";\r\n\r\nimport type { AuthState } from \"./AuthState\";\r\n\r\ntype Action =\r\n    | { type: \"INITIALISED\" | \"USER_LOADED\"; user: User | null }\r\n    | { type: \"USER_UNLOADED\" }\r\n    | { type: \"USER_SIGNED_OUT\" }\r\n    | { type: \"NAVIGATOR_INIT\"; method: NonNullable<AuthState[\"activeNavigator\"]> }\r\n    | { type: \"NAVIGATOR_CLOSE\" }\r\n    | { type: \"ERROR\"; error: Error };\r\n\r\n/**\r\n * Handles how that state changes in the `useAuth` hook.\r\n */\r\nexport const reducer = (state: AuthState, action: Action): AuthState => {\r\n    switch (action.type) {\r\n        case \"INITIALISED\":\r\n        case \"USER_LOADED\":\r\n            return {\r\n                ...state,\r\n                user: action.user,\r\n                isLoading: false,\r\n                isAuthenticated: action.user ? !action.user.expired : false,\r\n                error: undefined,\r\n            };\r\n        case \"USER_SIGNED_OUT\":\r\n        case \"USER_UNLOADED\":\r\n            return {\r\n                ...state,\r\n                user: undefined,\r\n                isAuthenticated: false,\r\n            };\r\n        case \"NAVIGATOR_INIT\":\r\n            return {\r\n                ...state,\r\n                isLoading: true,\r\n                activeNavigator: action.method,\r\n            };\r\n        case \"NAVIGATOR_CLOSE\":\r\n            // we intentionally don't handle cases where multiple concurrent navigators are open\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                activeNavigator: undefined,\r\n            };\r\n        case \"ERROR\":\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                error: action.error,\r\n            };\r\n        default:\r\n            return {\r\n                ...state,\r\n                isLoading: false,\r\n                error: new Error(`unknown type ${action[\"type\"] as string}`),\r\n            };\r\n    }\r\n};\r\n", "/**\r\n * @public\r\n */\r\nexport const hasAuthParams = (location = window.location): boolean => {\r\n    // response_mode: query\r\n    let searchParams = new URLSearchParams(location.search);\r\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\r\n        searchParams.get(\"state\")) {\r\n        return true;\r\n    }\r\n\r\n    // response_mode: fragment\r\n    searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\r\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\r\n        searchParams.get(\"state\")) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nconst normalizeErrorFn = (fallbackMessage: string) => (error: unknown): Error => {\r\n    if (error instanceof Error) {\r\n        return error;\r\n    }\r\n    return new Error(fallbackMessage);\r\n};\r\n\r\nexport const signinError = normalizeErrorFn(\"Sign-in failed\");\r\nexport const signoutError = normalizeErrorFn(\"Sign-out failed\");\r\n", "import React from \"react\";\r\n\r\nimport { AuthContext, type AuthContextProps } from \"./AuthContext\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport const useAuth = (): AuthContextProps => {\r\n    const context = React.useContext(AuthContext);\r\n\r\n    if (!context) {\r\n        console.warn(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\r\n    }\r\n\r\n    return context as AuthContextProps;\r\n};\r\n", "import React from \"react\";\r\n\r\nimport type { AuthContextProps } from \"./AuthContext\";\r\nimport { useAuth } from \"./useAuth\";\r\n\r\n/**\r\n * A public higher-order component to access the imperative API\r\n * @public\r\n */\r\nexport function withAuth<P>(\r\n    Component: React.ComponentType<P>,\r\n): React.ComponentType<Omit<P, keyof AuthContextProps>> {\r\n    const displayName = `withAuth(${Component.displayName || Component.name})`;\r\n    const C: React.FC<Omit<P, keyof AuthContextProps>> = (props) => {\r\n        const auth = useAuth();\r\n\r\n        return <Component {...(props as P)} auth={auth} />;\r\n    };\r\n\r\n    C.displayName = displayName;\r\n\r\n    return C;\r\n}\r\n", "import React from \"react\";\r\nimport type { SigninRedirectArgs } from \"oidc-client-ts\";\r\n\r\nimport { useAuth } from \"./useAuth\";\r\nimport { hasAuthParams } from \"./utils\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface WithAuthenticationRequiredProps {\r\n    /**\r\n     * Show a message when redirected to the signin page.\r\n     */\r\n    OnRedirecting?: () => React.JSX.Element;\r\n\r\n    /**\r\n     * Allows executing logic before the user is redirected to the signin page.\r\n     */\r\n    onBeforeSignin?: () => Promise<void> | void;\r\n\r\n    /**\r\n     * Pass additional signin redirect arguments.\r\n     */\r\n    signinRedirectArgs?: SigninRedirectArgs;\r\n}\r\n\r\n/**\r\n * A public higher-order component to protect accessing not public content. When you wrap your components in this higher-order\r\n * component and an anonymous user visits your component, they will be redirected to the login page; after logging in, they\r\n * will return to the page from which they were redirected.\r\n *\r\n * @public\r\n */\r\nexport const withAuthenticationRequired = <P extends object>(\r\n    Component: React.ComponentType<P>,\r\n    options: WithAuthenticationRequiredProps = {},\r\n): React.FC<P> => {\r\n    const { OnRedirecting = (): React.JSX.Element => <></>, onBeforeSignin, signinRedirectArgs } = options;\r\n    const displayName = `withAuthenticationRequired(${Component.displayName || Component.name})`;\r\n    const C: React.FC<P> = (props) => {\r\n        const auth = useAuth();\r\n\r\n        React.useEffect(() => {\r\n            if (hasAuthParams() ||\r\n                auth.isLoading || auth.activeNavigator || auth.isAuthenticated) {\r\n                return;\r\n            }\r\n            void (async (): Promise<void> => {\r\n                if (onBeforeSignin) await onBeforeSignin();\r\n                await auth.signinRedirect(signinRedirectArgs);\r\n            })();\r\n        }, [auth.isLoading, auth.isAuthenticated, auth]);\r\n\r\n        return auth.isAuthenticated ? <Component {...props} /> : OnRedirecting();\r\n    };\r\n\r\n    C.displayName = displayName;\r\n\r\n    return C;\r\n};\r\n"],
  "mappings": "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",
  "names": ["React", "React", "React", "React", "React", "React", "React", "React"]
}
